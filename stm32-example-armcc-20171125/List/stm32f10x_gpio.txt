; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: armcc [4d3621]
; commandline armcc [--list --debug -c --asm --interleave --output_dir=Obj --asm_dir=List --depend_dir=Obj --list_dir=List --md --cpu=Cortex-M3 --apcs=interwork -O0 -ISource/FWLib/inc -ISource -DSTM32F10X_HD Source/FWLib/src/stm32f10x_gpio.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;50     *******************************************************************************/
;;;51     void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  b510              PUSH     {r4,lr}
;;;52     {
000002  4604              MOV      r4,r0
;;;53       /* Check the parameters */
;;;54       assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;55       
;;;56       switch (*(u32*)&GPIOx)
000004  49c5              LDR      r1,|L1.796|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d02f              BEQ      |L1.108|
00000c  dc09              BGT      |L1.34|
00000e  48c4              LDR      r0,|L1.800|
000010  4420              ADD      r0,r0,r4
000012  b180              CBZ      r0,|L1.54|
000014  f5b06f80          CMP      r0,#0x400
000018  d016              BEQ      |L1.72|
00001a  f5b06f00          CMP      r0,#0x800
00001e  d14a              BNE      |L1.182|
000020  e01b              B        |L1.90|
                  |L1.34|
000022  f5b06f80          CMP      r0,#0x400
000026  d02a              BEQ      |L1.126|
000028  f5b06f00          CMP      r0,#0x800
00002c  d030              BEQ      |L1.144|
00002e  f5b06f40          CMP      r0,#0xc00
000032  d140              BNE      |L1.182|
000034  e035              B        |L1.162|
                  |L1.54|
;;;57       {
;;;58         case GPIOA_BASE:
;;;59           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
000036  2101              MOVS     r1,#1
000038  2004              MOVS     r0,#4
00003a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;60           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
00003e  2100              MOVS     r1,#0
000040  2004              MOVS     r0,#4
000042  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;61           break;
000046  e037              B        |L1.184|
                  |L1.72|
;;;62     
;;;63         case GPIOB_BASE:
;;;64           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
000048  2101              MOVS     r1,#1
00004a  2008              MOVS     r0,#8
00004c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;65           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
000050  2100              MOVS     r1,#0
000052  2008              MOVS     r0,#8
000054  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;66           break;
000058  e02e              B        |L1.184|
                  |L1.90|
;;;67     
;;;68         case GPIOC_BASE:
;;;69           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
00005a  2101              MOVS     r1,#1
00005c  2010              MOVS     r0,#0x10
00005e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;70           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
000062  2100              MOVS     r1,#0
000064  2010              MOVS     r0,#0x10
000066  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;71           break;
00006a  e025              B        |L1.184|
                  |L1.108|
;;;72     
;;;73         case GPIOD_BASE:
;;;74           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2020              MOVS     r0,#0x20
000070  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;75           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
000074  2100              MOVS     r1,#0
000076  2020              MOVS     r0,#0x20
000078  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;76           break;
00007c  e01c              B        |L1.184|
                  |L1.126|
;;;77           
;;;78         case GPIOE_BASE:
;;;79           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
00007e  2101              MOVS     r1,#1
000080  2040              MOVS     r0,#0x40
000082  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;80           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
000086  2100              MOVS     r1,#0
000088  2040              MOVS     r0,#0x40
00008a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;81           break; 
00008e  e013              B        |L1.184|
                  |L1.144|
;;;82     
;;;83         case GPIOF_BASE:
;;;84           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
000090  2101              MOVS     r1,#1
000092  2080              MOVS     r0,#0x80
000094  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;85           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
000098  2100              MOVS     r1,#0
00009a  2080              MOVS     r0,#0x80
00009c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;86           break;
0000a0  e00a              B        |L1.184|
                  |L1.162|
;;;87     
;;;88         case GPIOG_BASE:
;;;89           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  0208              LSLS     r0,r1,#8
0000a6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;90           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
0000aa  2100              MOVS     r1,#0
0000ac  f44f7080          MOV      r0,#0x100
0000b0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;91           break;                       
0000b4  e000              B        |L1.184|
                  |L1.182|
;;;92     
;;;93         default:
;;;94           break;
0000b6  bf00              NOP      
                  |L1.184|
0000b8  bf00              NOP                            ;61
;;;95       }
;;;96     }
0000ba  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  GPIO_AFIODeInit PROC
;;;106    *******************************************************************************/
;;;107    void GPIO_AFIODeInit(void)
0000bc  b510              PUSH     {r4,lr}
;;;108    {
;;;109      RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4608              MOV      r0,r1
0000c2  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;110      RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
0000c6  2100              MOVS     r1,#0
0000c8  2001              MOVS     r0,#1
0000ca  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;111    }
0000ce  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  GPIO_Init PROC
;;;123    *******************************************************************************/
;;;124    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
0000d0  e92d41f0          PUSH     {r4-r8,lr}
;;;125    {
0000d4  4602              MOV      r2,r0
;;;126      u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
0000d6  2500              MOVS     r5,#0
0000d8  2600              MOVS     r6,#0
0000da  2000              MOVS     r0,#0
0000dc  2300              MOVS     r3,#0
;;;127      u32 tmpreg = 0x00, pinmask = 0x00;
0000de  2400              MOVS     r4,#0
0000e0  2700              MOVS     r7,#0
;;;128    
;;;129      /* Check the parameters */
;;;130      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;131      assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;132      assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
;;;133      
;;;134    /*---------------------------- GPIO Mode Configuration -----------------------*/
;;;135      currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
0000e2  f891c003          LDRB     r12,[r1,#3]
0000e6  f00c050f          AND      r5,r12,#0xf
;;;136    
;;;137      if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
0000ea  f891c003          LDRB     r12,[r1,#3]
0000ee  f00c0c10          AND      r12,r12,#0x10
0000f2  f1bc0f00          CMP      r12,#0
0000f6  d003              BEQ      |L1.256|
;;;138      { 
;;;139        /* Check the parameters */
;;;140        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
;;;141        /* Output mode */
;;;142        currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
0000f8  f891c002          LDRB     r12,[r1,#2]
0000fc  ea4c0505          ORR      r5,r12,r5
                  |L1.256|
;;;143      }
;;;144    
;;;145    /*---------------------------- GPIO CRL Configuration ------------------------*/
;;;146      /* Configure the eight low port pins */
;;;147      if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
000100  f891c000          LDRB     r12,[r1,#0]
000104  f1bc0f00          CMP      r12,#0
000108  d030              BEQ      |L1.364|
;;;148      {
;;;149        tmpreg = GPIOx->CRL;
00010a  6814              LDR      r4,[r2,#0]
;;;150    
;;;151        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
00010c  2000              MOVS     r0,#0
00010e  e02a              B        |L1.358|
                  |L1.272|
;;;152        {
;;;153          pos = ((u32)0x01) << pinpos;
000110  f04f0c01          MOV      r12,#1
000114  fa0cf300          LSL      r3,r12,r0
;;;154          /* Get the port pins position */
;;;155          currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
000118  f8b1c000          LDRH     r12,[r1,#0]
00011c  ea0c0603          AND      r6,r12,r3
;;;156    
;;;157          if (currentpin == pos)
000120  429e              CMP      r6,r3
000122  d11f              BNE      |L1.356|
;;;158          {
;;;159            pos = pinpos << 2;
000124  0083              LSLS     r3,r0,#2
;;;160            /* Clear the corresponding low control register bits */
;;;161            pinmask = ((u32)0x0F) << pos;
000126  f04f0c0f          MOV      r12,#0xf
00012a  fa0cf703          LSL      r7,r12,r3
;;;162            tmpreg &= ~pinmask;
00012e  43bc              BICS     r4,r4,r7
;;;163    
;;;164            /* Write the mode configuration in the corresponding bits */
;;;165            tmpreg |= (currentmode << pos);
000130  fa05fc03          LSL      r12,r5,r3
000134  ea4c0404          ORR      r4,r12,r4
;;;166    
;;;167            /* Reset the corresponding ODR bit */
;;;168            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
000138  f891c003          LDRB     r12,[r1,#3]
00013c  f1bc0f28          CMP      r12,#0x28
000140  d105              BNE      |L1.334|
;;;169            {
;;;170              GPIOx->BRR = (((u32)0x01) << pinpos);
000142  f04f0c01          MOV      r12,#1
000146  fa0cfc00          LSL      r12,r12,r0
00014a  f8c2c014          STR      r12,[r2,#0x14]
                  |L1.334|
;;;171            }
;;;172            /* Set the corresponding ODR bit */
;;;173            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
00014e  f891c003          LDRB     r12,[r1,#3]
000152  f1bc0f48          CMP      r12,#0x48
000156  d105              BNE      |L1.356|
;;;174            {
;;;175              GPIOx->BSRR = (((u32)0x01) << pinpos);
000158  f04f0c01          MOV      r12,#1
00015c  fa0cfc00          LSL      r12,r12,r0
000160  f8c2c010          STR      r12,[r2,#0x10]
                  |L1.356|
000164  1c40              ADDS     r0,r0,#1              ;151
                  |L1.358|
000166  2808              CMP      r0,#8                 ;151
000168  d3d2              BCC      |L1.272|
;;;176            }
;;;177          }
;;;178        }
;;;179        GPIOx->CRL = tmpreg;
00016a  6014              STR      r4,[r2,#0]
                  |L1.364|
;;;180      }
;;;181    
;;;182    /*---------------------------- GPIO CRH Configuration ------------------------*/
;;;183      /* Configure the eight high port pins */
;;;184      if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
00016c  f8b1c000          LDRH     r12,[r1,#0]
000170  f1bc0fff          CMP      r12,#0xff
000174  dd34              BLE      |L1.480|
;;;185      {
;;;186        tmpreg = GPIOx->CRH;
000176  6854              LDR      r4,[r2,#4]
;;;187        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
000178  2000              MOVS     r0,#0
00017a  e02e              B        |L1.474|
                  |L1.380|
;;;188        {
;;;189          pos = (((u32)0x01) << (pinpos + 0x08));
00017c  f1000c08          ADD      r12,r0,#8
000180  f04f0801          MOV      r8,#1
000184  fa08f30c          LSL      r3,r8,r12
;;;190          /* Get the port pins position */
;;;191          currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
000188  f8b1c000          LDRH     r12,[r1,#0]
00018c  ea0c0603          AND      r6,r12,r3
;;;192          if (currentpin == pos)
000190  429e              CMP      r6,r3
000192  d121              BNE      |L1.472|
;;;193          {
;;;194            pos = pinpos << 2;
000194  0083              LSLS     r3,r0,#2
;;;195            /* Clear the corresponding high control register bits */
;;;196            pinmask = ((u32)0x0F) << pos;
000196  f04f0c0f          MOV      r12,#0xf
00019a  fa0cf703          LSL      r7,r12,r3
;;;197            tmpreg &= ~pinmask;
00019e  43bc              BICS     r4,r4,r7
;;;198    
;;;199            /* Write the mode configuration in the corresponding bits */
;;;200            tmpreg |= (currentmode << pos);
0001a0  fa05fc03          LSL      r12,r5,r3
0001a4  ea4c0404          ORR      r4,r12,r4
;;;201    
;;;202            /* Reset the corresponding ODR bit */
;;;203            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
0001a8  f891c003          LDRB     r12,[r1,#3]
0001ac  f1bc0f28          CMP      r12,#0x28
0001b0  d105              BNE      |L1.446|
;;;204            {
;;;205              GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
0001b2  f1000c08          ADD      r12,r0,#8
0001b6  fa08f80c          LSL      r8,r8,r12
0001ba  f8c28014          STR      r8,[r2,#0x14]
                  |L1.446|
;;;206            }
;;;207            /* Set the corresponding ODR bit */
;;;208            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
0001be  f891c003          LDRB     r12,[r1,#3]
0001c2  f1bc0f48          CMP      r12,#0x48
0001c6  d107              BNE      |L1.472|
;;;209            {
;;;210              GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
0001c8  f1000c08          ADD      r12,r0,#8
0001cc  f04f0801          MOV      r8,#1
0001d0  fa08f80c          LSL      r8,r8,r12
0001d4  f8c28010          STR      r8,[r2,#0x10]
                  |L1.472|
0001d8  1c40              ADDS     r0,r0,#1              ;187
                  |L1.474|
0001da  2808              CMP      r0,#8                 ;187
0001dc  d3ce              BCC      |L1.380|
;;;211            }
;;;212          }
;;;213        }
;;;214        GPIOx->CRH = tmpreg;
0001de  6054              STR      r4,[r2,#4]
                  |L1.480|
;;;215      }
;;;216    }
0001e0  e8bd81f0          POP      {r4-r8,pc}
;;;217    
                          ENDP

                  GPIO_StructInit PROC
;;;225    *******************************************************************************/
;;;226    void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
0001e4  f64f71ff          MOV      r1,#0xffff
;;;227    {
;;;228      /* Reset GPIO init structure parameters values */
;;;229      GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
0001e8  8001              STRH     r1,[r0,#0]
;;;230      GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
0001ea  2102              MOVS     r1,#2
0001ec  7081              STRB     r1,[r0,#2]
;;;231      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
0001ee  2104              MOVS     r1,#4
0001f0  70c1              STRB     r1,[r0,#3]
;;;232    }
0001f2  4770              BX       lr
;;;233    
                          ENDP

                  GPIO_ReadInputDataBit PROC
;;;242    *******************************************************************************/
;;;243    u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
0001f4  4602              MOV      r2,r0
;;;244    {
;;;245      u8 bitstatus = 0x00;
0001f6  2000              MOVS     r0,#0
;;;246      
;;;247      /* Check the parameters */
;;;248      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;249      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;250      
;;;251      if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
0001f8  6893              LDR      r3,[r2,#8]
0001fa  400b              ANDS     r3,r3,r1
0001fc  b10b              CBZ      r3,|L1.514|
;;;252      {
;;;253        bitstatus = (u8)Bit_SET;
0001fe  2001              MOVS     r0,#1
000200  e000              B        |L1.516|
                  |L1.514|
;;;254      }
;;;255      else
;;;256      {
;;;257        bitstatus = (u8)Bit_RESET;
000202  2000              MOVS     r0,#0
                  |L1.516|
;;;258      }
;;;259      return bitstatus;
;;;260    }
000204  4770              BX       lr
;;;261    
                          ENDP

                  GPIO_ReadInputData PROC
;;;268    *******************************************************************************/
;;;269    u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000206  4601              MOV      r1,r0
;;;270    {
;;;271      /* Check the parameters */
;;;272      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;273      
;;;274      return ((u16)GPIOx->IDR);
000208  6888              LDR      r0,[r1,#8]
00020a  b280              UXTH     r0,r0
;;;275    }
00020c  4770              BX       lr
;;;276    
                          ENDP

                  GPIO_ReadOutputDataBit PROC
;;;285    *******************************************************************************/
;;;286    u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
00020e  4602              MOV      r2,r0
;;;287    {
;;;288      u8 bitstatus = 0x00;
000210  2000              MOVS     r0,#0
;;;289    
;;;290      /* Check the parameters */
;;;291      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;292      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;293      
;;;294      if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
000212  68d3              LDR      r3,[r2,#0xc]
000214  400b              ANDS     r3,r3,r1
000216  b10b              CBZ      r3,|L1.540|
;;;295      {
;;;296        bitstatus = (u8)Bit_SET;
000218  2001              MOVS     r0,#1
00021a  e000              B        |L1.542|
                  |L1.540|
;;;297      }
;;;298      else
;;;299      {
;;;300        bitstatus = (u8)Bit_RESET;
00021c  2000              MOVS     r0,#0
                  |L1.542|
;;;301      }
;;;302      return bitstatus;
;;;303    }
00021e  4770              BX       lr
;;;304    
                          ENDP

                  GPIO_ReadOutputData PROC
;;;311    *******************************************************************************/
;;;312    u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000220  4601              MOV      r1,r0
;;;313    {
;;;314      /* Check the parameters */
;;;315      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;316        
;;;317      return ((u16)GPIOx->ODR);
000222  68c8              LDR      r0,[r1,#0xc]
000224  b280              UXTH     r0,r0
;;;318    }
000226  4770              BX       lr
;;;319    
                          ENDP

                  GPIO_SetBits PROC
;;;329    *******************************************************************************/
;;;330    void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000228  6101              STR      r1,[r0,#0x10]
;;;331    {
;;;332      /* Check the parameters */
;;;333      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;334      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;335      
;;;336      GPIOx->BSRR = GPIO_Pin;
;;;337    }
00022a  4770              BX       lr
;;;338    
                          ENDP

                  GPIO_ResetBits PROC
;;;348    *******************************************************************************/
;;;349    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
00022c  6141              STR      r1,[r0,#0x14]
;;;350    {
;;;351      /* Check the parameters */
;;;352      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;353      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;354      
;;;355      GPIOx->BRR = GPIO_Pin;
;;;356    }
00022e  4770              BX       lr
;;;357    
                          ENDP

                  GPIO_WriteBit PROC
;;;370    *******************************************************************************/
;;;371    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
000230  b10a              CBZ      r2,|L1.566|
;;;372    {
;;;373      /* Check the parameters */
;;;374      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;375      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;376      assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
;;;377      
;;;378      if (BitVal != Bit_RESET)
;;;379      {
;;;380        GPIOx->BSRR = GPIO_Pin;
000232  6101              STR      r1,[r0,#0x10]
000234  e000              B        |L1.568|
                  |L1.566|
;;;381      }
;;;382      else
;;;383      {
;;;384        GPIOx->BRR = GPIO_Pin;
000236  6141              STR      r1,[r0,#0x14]
                  |L1.568|
;;;385      }
;;;386    }
000238  4770              BX       lr
;;;387    
                          ENDP

                  GPIO_Write PROC
;;;396    *******************************************************************************/
;;;397    void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
00023a  60c1              STR      r1,[r0,#0xc]
;;;398    {
;;;399      /* Check the parameters */
;;;400      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;401      
;;;402      GPIOx->ODR = PortVal;
;;;403    }
00023c  4770              BX       lr
;;;404    
                          ENDP

                  GPIO_PinLockConfig PROC
;;;414    *******************************************************************************/
;;;415    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
00023e  f44f3280          MOV      r2,#0x10000
;;;416    {
;;;417      u32 tmp = 0x00010000;
;;;418      
;;;419      /* Check the parameters */
;;;420      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;421      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;422      
;;;423      tmp |= GPIO_Pin;
000242  430a              ORRS     r2,r2,r1
;;;424      /* Set LCKK bit */
;;;425      GPIOx->LCKR = tmp;
000244  6182              STR      r2,[r0,#0x18]
;;;426      /* Reset LCKK bit */
;;;427      GPIOx->LCKR =  GPIO_Pin;
000246  6181              STR      r1,[r0,#0x18]
;;;428      /* Set LCKK bit */
;;;429      GPIOx->LCKR = tmp;
000248  6182              STR      r2,[r0,#0x18]
;;;430      /* Read LCKK bit*/
;;;431      tmp = GPIOx->LCKR;
00024a  6982              LDR      r2,[r0,#0x18]
;;;432      /* Read LCKK bit*/
;;;433      tmp = GPIOx->LCKR;
00024c  6982              LDR      r2,[r0,#0x18]
;;;434    }
00024e  4770              BX       lr
;;;435    
                          ENDP

                  GPIO_EventOutputConfig PROC
;;;447    *******************************************************************************/
;;;448    void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
000250  4602              MOV      r2,r0
;;;449    {
;;;450      u32 tmpreg = 0x00;
000252  2000              MOVS     r0,#0
;;;451    
;;;452      /* Check the parameters */
;;;453      assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
;;;454      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;455        
;;;456      tmpreg = AFIO->EVCR;
000254  4b33              LDR      r3,|L1.804|
000256  6818              LDR      r0,[r3,#0]
;;;457      /* Clear the PORT[6:4] and PIN[3:0] bits */
;;;458      tmpreg &= EVCR_PORTPINCONFIG_MASK;
000258  f64f7380          MOV      r3,#0xff80
00025c  4018              ANDS     r0,r0,r3
;;;459      tmpreg |= (u32)GPIO_PortSource << 0x04;
00025e  ea401002          ORR      r0,r0,r2,LSL #4
;;;460      tmpreg |= GPIO_PinSource;
000262  4308              ORRS     r0,r0,r1
;;;461    
;;;462      AFIO->EVCR = tmpreg;
000264  4b2f              LDR      r3,|L1.804|
000266  6018              STR      r0,[r3,#0]
;;;463    }
000268  4770              BX       lr
;;;464    
                          ENDP

                  GPIO_EventOutputCmd PROC
;;;472    *******************************************************************************/
;;;473    void GPIO_EventOutputCmd(FunctionalState NewState)
00026a  492f              LDR      r1,|L1.808|
;;;474    {
;;;475      /* Check the parameters */
;;;476      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;477      
;;;478      *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
00026c  61c8              STR      r0,[r1,#0x1c]
;;;479    }
00026e  4770              BX       lr
;;;480    
                          ENDP

                  GPIO_PinRemapConfig PROC
;;;515    *******************************************************************************/
;;;516    void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
000270  b5f0              PUSH     {r4-r7,lr}
;;;517    {
000272  460a              MOV      r2,r1
;;;518      u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
000274  2300              MOVS     r3,#0
000276  2400              MOVS     r4,#0
000278  2100              MOVS     r1,#0
00027a  2500              MOVS     r5,#0
;;;519    
;;;520      /* Check the parameters */
;;;521      assert_param(IS_GPIO_REMAP(GPIO_Remap));
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;523      
;;;524      tmpreg = AFIO->MAPR;
00027c  4e29              LDR      r6,|L1.804|
00027e  6871              LDR      r1,[r6,#4]
;;;525    
;;;526      tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
000280  f3c04503          UBFX     r5,r0,#16,#4
;;;527      tmp = GPIO_Remap & LSB_MASK;
000284  b283              UXTH     r3,r0
;;;528    
;;;529      if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
000286  f4001640          AND      r6,r0,#0x300000
00028a  f5b61f40          CMP      r6,#0x300000
00028e  d108              BNE      |L1.674|
;;;530      {
;;;531        tmpreg &= DBGAFR_SWJCFG_MASK;
000290  f0216170          BIC      r1,r1,#0xf000000
;;;532        AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
000294  4e23              LDR      r6,|L1.804|
000296  6876              LDR      r6,[r6,#4]
000298  f0266670          BIC      r6,r6,#0xf000000
00029c  4f21              LDR      r7,|L1.804|
00029e  607e              STR      r6,[r7,#4]
0002a0  e012              B        |L1.712|
                  |L1.674|
;;;533      }
;;;534      else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
0002a2  f4001680          AND      r6,r0,#0x100000
0002a6  f5b61f80          CMP      r6,#0x100000
0002aa  d106              BNE      |L1.698|
;;;535      {
;;;536        tmp1 = ((u32)0x03) << tmpmask;
0002ac  2603              MOVS     r6,#3
0002ae  fa06f405          LSL      r4,r6,r5
;;;537        tmpreg &= ~tmp1;
0002b2  43a1              BICS     r1,r1,r4
;;;538        tmpreg |= ~DBGAFR_SWJCFG_MASK;
0002b4  f0416170          ORR      r1,r1,#0xf000000
0002b8  e006              B        |L1.712|
                  |L1.698|
;;;539      }
;;;540      else
;;;541      {
;;;542        tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
0002ba  0d46              LSRS     r6,r0,#21
0002bc  0136              LSLS     r6,r6,#4
0002be  fa03f606          LSL      r6,r3,r6
0002c2  43b1              BICS     r1,r1,r6
;;;543        tmpreg |= ~DBGAFR_SWJCFG_MASK;
0002c4  f0416170          ORR      r1,r1,#0xf000000
                  |L1.712|
;;;544      }
;;;545    
;;;546      if (NewState != DISABLE)
0002c8  b122              CBZ      r2,|L1.724|
;;;547      {
;;;548        tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
0002ca  0d46              LSRS     r6,r0,#21
0002cc  0136              LSLS     r6,r6,#4
0002ce  fa03f606          LSL      r6,r3,r6
0002d2  4331              ORRS     r1,r1,r6
                  |L1.724|
;;;549      }
;;;550    
;;;551      AFIO->MAPR = tmpreg;
0002d4  4e13              LDR      r6,|L1.804|
0002d6  6071              STR      r1,[r6,#4]
;;;552    }
0002d8  bdf0              POP      {r4-r7,pc}
;;;553    
                          ENDP

                  GPIO_EXTILineConfig PROC
;;;565    *******************************************************************************/
;;;566    void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
0002da  b530              PUSH     {r4,r5,lr}
;;;567    {
;;;568      u32 tmp = 0x00;
0002dc  2200              MOVS     r2,#0
;;;569    
;;;570      /* Check the parameters */
;;;571      assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
;;;572      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;573      
;;;574      tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
0002de  078b              LSLS     r3,r1,#30
0002e0  0f1c              LSRS     r4,r3,#28
0002e2  230f              MOVS     r3,#0xf
0002e4  fa03f204          LSL      r2,r3,r4
;;;575    
;;;576      AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
0002e8  4b0e              LDR      r3,|L1.804|
0002ea  3308              ADDS     r3,r3,#8
0002ec  108c              ASRS     r4,r1,#2
0002ee  f8533024          LDR      r3,[r3,r4,LSL #2]
0002f2  4393              BICS     r3,r3,r2
0002f4  4c0b              LDR      r4,|L1.804|
0002f6  3408              ADDS     r4,r4,#8
0002f8  108d              ASRS     r5,r1,#2
0002fa  f8443025          STR      r3,[r4,r5,LSL #2]
;;;577      AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
0002fe  4623              MOV      r3,r4
000300  108c              ASRS     r4,r1,#2
000302  f8533024          LDR      r3,[r3,r4,LSL #2]
000306  078c              LSLS     r4,r1,#30
000308  0f24              LSRS     r4,r4,#28
00030a  fa00f404          LSL      r4,r0,r4
00030e  4323              ORRS     r3,r3,r4
000310  4c04              LDR      r4,|L1.804|
000312  3408              ADDS     r4,r4,#8
000314  108d              ASRS     r5,r1,#2
000316  f8443025          STR      r3,[r4,r5,LSL #2]
;;;578    }
00031a  bd30              POP      {r4,r5,pc}
;;;579    
                          ENDP

                  |L1.796|
                          DCD      0x40011400
                  |L1.800|
                          DCD      0xbffef800
                  |L1.804|
                          DCD      0x40010000
                  |L1.808|
                          DCD      0x42200000
