; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: armcc [4d3621]
; commandline armcc [--list --debug -c --asm --interleave --output_dir=Obj --asm_dir=List --depend_dir=Obj --list_dir=List --md --cpu=Cortex-M3 --apcs=interwork -O0 -ISource/FWLib/inc -ISource -DSTM32F10X_HD Source/FWLib/src/stm32f10x_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;124    *******************************************************************************/
;;;125    void RCC_DeInit(void)
000000  48e0              LDR      r0,|L1.900|
;;;126    {
;;;127      /* Set HSION bit */
;;;128      RCC->CR |= (u32)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  49de              LDR      r1,|L1.900|
00000a  6008              STR      r0,[r1,#0]
;;;129    
;;;130      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;131      RCC->CFGR &= (u32)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  49dd              LDR      r1,|L1.904|
000012  4008              ANDS     r0,r0,r1
000014  49db              LDR      r1,|L1.900|
000016  6048              STR      r0,[r1,#4]
;;;132      
;;;133      /* Reset HSEON, CSSON and PLLON bits */
;;;134      RCC->CR &= (u32)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  49db              LDR      r1,|L1.908|
00001e  4008              ANDS     r0,r0,r1
000020  49d8              LDR      r1,|L1.900|
000022  6008              STR      r0,[r1,#0]
;;;135    
;;;136      /* Reset HSEBYP bit */
;;;137      RCC->CR &= (u32)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;138    
;;;139      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;140      RCC->CFGR &= (u32)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;141    
;;;142      /* Disable all interrupts */
;;;143      RCC->CIR = 0x00000000;
000038  2000              MOVS     r0,#0
00003a  6088              STR      r0,[r1,#8]
;;;144    }
00003c  4770              BX       lr
;;;145    
                          ENDP

                  RCC_HSEConfig PROC
;;;159    *******************************************************************************/
;;;160    void RCC_HSEConfig(u32 RCC_HSE)
00003e  49d1              LDR      r1,|L1.900|
;;;161    {
;;;162      /* Check the parameters */
;;;163      assert_param(IS_RCC_HSE(RCC_HSE));
;;;164    
;;;165      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;166      /* Reset HSEON bit */
;;;167      RCC->CR &= CR_HSEON_Reset;
000040  6809              LDR      r1,[r1,#0]
000042  f4213180          BIC      r1,r1,#0x10000
000046  4acf              LDR      r2,|L1.900|
000048  6011              STR      r1,[r2,#0]
;;;168    
;;;169      /* Reset HSEBYP bit */
;;;170      RCC->CR &= CR_HSEBYP_Reset;
00004a  4611              MOV      r1,r2
00004c  6809              LDR      r1,[r1,#0]
00004e  f4212180          BIC      r1,r1,#0x40000
000052  6011              STR      r1,[r2,#0]
;;;171    
;;;172      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;173      switch(RCC_HSE)
000054  f5b03f80          CMP      r0,#0x10000
000058  d003              BEQ      |L1.98|
00005a  f5b02f80          CMP      r0,#0x40000
00005e  d10e              BNE      |L1.126|
000060  e006              B        |L1.112|
                  |L1.98|
;;;174      {
;;;175        case RCC_HSE_ON:
;;;176          /* Set HSEON bit */
;;;177          RCC->CR |= CR_HSEON_Set;
000062  49c8              LDR      r1,|L1.900|
000064  6809              LDR      r1,[r1,#0]
000066  f4413180          ORR      r1,r1,#0x10000
00006a  4ac6              LDR      r2,|L1.900|
00006c  6011              STR      r1,[r2,#0]
;;;178          break;
00006e  e007              B        |L1.128|
                  |L1.112|
;;;179          
;;;180        case RCC_HSE_Bypass:
;;;181          /* Set HSEBYP and HSEON bits */
;;;182          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000070  49c4              LDR      r1,|L1.900|
000072  6809              LDR      r1,[r1,#0]
000074  f44121a0          ORR      r1,r1,#0x50000
000078  4ac2              LDR      r2,|L1.900|
00007a  6011              STR      r1,[r2,#0]
;;;183          break;            
00007c  e000              B        |L1.128|
                  |L1.126|
;;;184          
;;;185        default:
;;;186          break;      
00007e  bf00              NOP      
                  |L1.128|
000080  bf00              NOP                            ;178
;;;187      }
;;;188    }
000082  4770              BX       lr
;;;189    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;987    *******************************************************************************/
;;;988    FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
000084  b510              PUSH     {r4,lr}
;;;989    {
000086  4601              MOV      r1,r0
;;;990      u32 tmp = 0;
000088  2200              MOVS     r2,#0
;;;991      u32 statusreg = 0;
00008a  2300              MOVS     r3,#0
;;;992      FlagStatus bitstatus = RESET;
00008c  2000              MOVS     r0,#0
;;;993    
;;;994      /* Check the parameters */
;;;995      assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;996    
;;;997      /* Get the RCC register index */
;;;998      tmp = RCC_FLAG >> 5;
00008e  114a              ASRS     r2,r1,#5
;;;999    
;;;1000     if (tmp == 1)               /* The flag to check is in CR register */
000090  2a01              CMP      r2,#1
000092  d102              BNE      |L1.154|
;;;1001     {
;;;1002       statusreg = RCC->CR;
000094  4cbb              LDR      r4,|L1.900|
000096  6823              LDR      r3,[r4,#0]
000098  e006              B        |L1.168|
                  |L1.154|
;;;1003     }
;;;1004     else if (tmp == 2)          /* The flag to check is in BDCR register */
00009a  2a02              CMP      r2,#2
00009c  d102              BNE      |L1.164|
;;;1005     {
;;;1006       statusreg = RCC->BDCR;
00009e  4cb9              LDR      r4,|L1.900|
0000a0  6a23              LDR      r3,[r4,#0x20]
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;1007     }
;;;1008     else                       /* The flag to check is in CSR register */
;;;1009     {
;;;1010       statusreg = RCC->CSR;
0000a4  4cb7              LDR      r4,|L1.900|
0000a6  6a63              LDR      r3,[r4,#0x24]
                  |L1.168|
;;;1011     }
;;;1012   
;;;1013     /* Get the flag position */
;;;1014     tmp = RCC_FLAG & FLAG_Mask;
0000a8  f001021f          AND      r2,r1,#0x1f
;;;1015   
;;;1016     if ((statusreg & ((u32)1 << tmp)) != (u32)RESET)
0000ac  2401              MOVS     r4,#1
0000ae  4094              LSLS     r4,r4,r2
0000b0  401c              ANDS     r4,r4,r3
0000b2  b10c              CBZ      r4,|L1.184|
;;;1017     {
;;;1018       bitstatus = SET;
0000b4  2001              MOVS     r0,#1
0000b6  e000              B        |L1.186|
                  |L1.184|
;;;1019     }
;;;1020     else
;;;1021     {
;;;1022       bitstatus = RESET;
0000b8  2000              MOVS     r0,#0
                  |L1.186|
;;;1023     }
;;;1024   
;;;1025     /* Return the flag status */
;;;1026     return bitstatus;
;;;1027   }
0000ba  bd10              POP      {r4,pc}
;;;1028   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;198    *******************************************************************************/
;;;199    ErrorStatus RCC_WaitForHSEStartUp(void)
0000bc  b510              PUSH     {r4,lr}
;;;200    {
;;;201      ErrorStatus status = ERROR;
0000be  2400              MOVS     r4,#0
;;;202    
;;;203      /* Wait till HSE is ready and if Time out is reached exit */
;;;204      do
0000c0  bf00              NOP      
                  |L1.194|
;;;205      {
;;;206        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
0000c2  2031              MOVS     r0,#0x31
0000c4  f7fffffe          BL       RCC_GetFlagStatus
0000c8  49b1              LDR      r1,|L1.912|
0000ca  7008              STRB     r0,[r1,#0]
;;;207        StartUpCounter++;  
0000cc  48b1              LDR      r0,|L1.916|
0000ce  6800              LDR      r0,[r0,#0]  ; StartUpCounter
0000d0  1c40              ADDS     r0,r0,#1
0000d2  49b0              LDR      r1,|L1.916|
0000d4  6008              STR      r0,[r1,#0]  ; StartUpCounter
;;;208      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
0000d6  48ae              LDR      r0,|L1.912|
0000d8  7800              LDRB     r0,[r0,#0]  ; HSEStatus
0000da  b928              CBNZ     r0,|L1.232|
0000dc  4608              MOV      r0,r1
0000de  6800              LDR      r0,[r0,#0]  ; StartUpCounter
0000e0  f24011ff          MOV      r1,#0x1ff
0000e4  4288              CMP      r0,r1
0000e6  d1ec              BNE      |L1.194|
                  |L1.232|
;;;209    
;;;210    
;;;211      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000e8  2031              MOVS     r0,#0x31
0000ea  f7fffffe          BL       RCC_GetFlagStatus
0000ee  b108              CBZ      r0,|L1.244|
;;;212      {
;;;213        status = SUCCESS;
0000f0  2401              MOVS     r4,#1
0000f2  e000              B        |L1.246|
                  |L1.244|
;;;214      }
;;;215      else
;;;216      {
;;;217        status = ERROR;
0000f4  2400              MOVS     r4,#0
                  |L1.246|
;;;218      }  
;;;219    
;;;220      return (status);
0000f6  4620              MOV      r0,r4
;;;221    }
0000f8  bd10              POP      {r4,pc}
;;;222    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;231    *******************************************************************************/
;;;232    void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
0000fa  4601              MOV      r1,r0
;;;233    {
;;;234      u32 tmpreg = 0;
0000fc  2000              MOVS     r0,#0
;;;235    
;;;236      /* Check the parameters */
;;;237      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;238    
;;;239      tmpreg = RCC->CR;
0000fe  4aa1              LDR      r2,|L1.900|
000100  6810              LDR      r0,[r2,#0]
;;;240    
;;;241      /* Clear HSITRIM[4:0] bits */
;;;242      tmpreg &= CR_HSITRIM_Mask;
000102  f02000f8          BIC      r0,r0,#0xf8
;;;243    
;;;244      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;245      tmpreg |= (u32)HSICalibrationValue << 3;
000106  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;246    
;;;247      /* Store the new value */
;;;248      RCC->CR = tmpreg;
00010a  6010              STR      r0,[r2,#0]
;;;249    }
00010c  4770              BX       lr
;;;250    
                          ENDP

                  RCC_HSICmd PROC
;;;260    *******************************************************************************/
;;;261    void RCC_HSICmd(FunctionalState NewState)
00010e  49a2              LDR      r1,|L1.920|
;;;262    {
;;;263      /* Check the parameters */
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265    
;;;266      *(vu32 *) CR_HSION_BB = (u32)NewState;
000110  6008              STR      r0,[r1,#0]
;;;267    }
000112  4770              BX       lr
;;;268    
                          ENDP

                  RCC_PLLConfig PROC
;;;285    *******************************************************************************/
;;;286    void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
000114  4602              MOV      r2,r0
;;;287    {
;;;288      u32 tmpreg = 0;
000116  2000              MOVS     r0,#0
;;;289    
;;;290      /* Check the parameters */
;;;291      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;292      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;293    
;;;294      tmpreg = RCC->CFGR;
000118  4b9a              LDR      r3,|L1.900|
00011a  6858              LDR      r0,[r3,#4]
;;;295    
;;;296      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;297      tmpreg &= CFGR_PLL_Mask;
00011c  f420107c          BIC      r0,r0,#0x3f0000
;;;298    
;;;299      /* Set the PLL configuration bits */
;;;300      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000120  ea420301          ORR      r3,r2,r1
000124  4318              ORRS     r0,r0,r3
;;;301    
;;;302      /* Store the new value */
;;;303      RCC->CFGR = tmpreg;
000126  4b97              LDR      r3,|L1.900|
000128  6058              STR      r0,[r3,#4]
;;;304    }
00012a  4770              BX       lr
;;;305    
                          ENDP

                  RCC_PLLCmd PROC
;;;314    *******************************************************************************/
;;;315    void RCC_PLLCmd(FunctionalState NewState)
00012c  499a              LDR      r1,|L1.920|
;;;316    {
;;;317      /* Check the parameters */
;;;318      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;319    
;;;320      *(vu32 *) CR_PLLON_BB = (u32)NewState;
00012e  6608              STR      r0,[r1,#0x60]
;;;321    }
000130  4770              BX       lr
;;;322    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;333    *******************************************************************************/
;;;334    void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
000132  4601              MOV      r1,r0
;;;335    {
;;;336      u32 tmpreg = 0;
000134  2000              MOVS     r0,#0
;;;337    
;;;338      /* Check the parameters */
;;;339      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;340    
;;;341      tmpreg = RCC->CFGR;
000136  4a93              LDR      r2,|L1.900|
000138  6850              LDR      r0,[r2,#4]
;;;342    
;;;343      /* Clear SW[1:0] bits */
;;;344      tmpreg &= CFGR_SW_Mask;
00013a  f0200003          BIC      r0,r0,#3
;;;345    
;;;346      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;347      tmpreg |= RCC_SYSCLKSource;
00013e  4308              ORRS     r0,r0,r1
;;;348    
;;;349      /* Store the new value */
;;;350      RCC->CFGR = tmpreg;
000140  6050              STR      r0,[r2,#4]
;;;351    }
000142  4770              BX       lr
;;;352    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;363    *******************************************************************************/
;;;364    u8 RCC_GetSYSCLKSource(void)
000144  488f              LDR      r0,|L1.900|
;;;365    {
;;;366      return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
000146  6840              LDR      r0,[r0,#4]
000148  f000000c          AND      r0,r0,#0xc
;;;367    }
00014c  4770              BX       lr
;;;368    
                          ENDP

                  RCC_HCLKConfig PROC
;;;386    *******************************************************************************/
;;;387    void RCC_HCLKConfig(u32 RCC_SYSCLK)
00014e  4601              MOV      r1,r0
;;;388    {
;;;389      u32 tmpreg = 0;
000150  2000              MOVS     r0,#0
;;;390    
;;;391      /* Check the parameters */
;;;392      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;393    
;;;394      tmpreg = RCC->CFGR;
000152  4a8c              LDR      r2,|L1.900|
000154  6850              LDR      r0,[r2,#4]
;;;395    
;;;396      /* Clear HPRE[3:0] bits */
;;;397      tmpreg &= CFGR_HPRE_Reset_Mask;
000156  f02000f0          BIC      r0,r0,#0xf0
;;;398    
;;;399      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;400      tmpreg |= RCC_SYSCLK;
00015a  4308              ORRS     r0,r0,r1
;;;401    
;;;402      /* Store the new value */
;;;403      RCC->CFGR = tmpreg;
00015c  6050              STR      r0,[r2,#4]
;;;404    }
00015e  4770              BX       lr
;;;405    
                          ENDP

                  RCC_PCLK1Config PROC
;;;419    *******************************************************************************/
;;;420    void RCC_PCLK1Config(u32 RCC_HCLK)
000160  4601              MOV      r1,r0
;;;421    {
;;;422      u32 tmpreg = 0;
000162  2000              MOVS     r0,#0
;;;423    
;;;424      /* Check the parameters */
;;;425      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;426    
;;;427      tmpreg = RCC->CFGR;
000164  4a87              LDR      r2,|L1.900|
000166  6850              LDR      r0,[r2,#4]
;;;428    
;;;429      /* Clear PPRE1[2:0] bits */
;;;430      tmpreg &= CFGR_PPRE1_Reset_Mask;
000168  f42060e0          BIC      r0,r0,#0x700
;;;431    
;;;432      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;433      tmpreg |= RCC_HCLK;
00016c  4308              ORRS     r0,r0,r1
;;;434    
;;;435      /* Store the new value */
;;;436      RCC->CFGR = tmpreg;
00016e  6050              STR      r0,[r2,#4]
;;;437    }
000170  4770              BX       lr
;;;438    
                          ENDP

                  RCC_PCLK2Config PROC
;;;452    *******************************************************************************/
;;;453    void RCC_PCLK2Config(u32 RCC_HCLK)
000172  4601              MOV      r1,r0
;;;454    {
;;;455      u32 tmpreg = 0;
000174  2000              MOVS     r0,#0
;;;456    
;;;457      /* Check the parameters */
;;;458      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;459    
;;;460      tmpreg = RCC->CFGR;
000176  4a83              LDR      r2,|L1.900|
000178  6850              LDR      r0,[r2,#4]
;;;461    
;;;462      /* Clear PPRE2[2:0] bits */
;;;463      tmpreg &= CFGR_PPRE2_Reset_Mask;
00017a  f4205060          BIC      r0,r0,#0x3800
;;;464    
;;;465      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;466      tmpreg |= RCC_HCLK << 3;
00017e  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;467    
;;;468      /* Store the new value */
;;;469      RCC->CFGR = tmpreg;
000182  6050              STR      r0,[r2,#4]
;;;470    }
000184  4770              BX       lr
;;;471    
                          ENDP

                  RCC_ITConfig PROC
;;;487    *******************************************************************************/
;;;488    void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
000186  b129              CBZ      r1,|L1.404|
;;;489    {
;;;490      /* Check the parameters */
;;;491      assert_param(IS_RCC_IT(RCC_IT));
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493    
;;;494      if (NewState != DISABLE)
;;;495      {
;;;496        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;497        *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
000188  4a7e              LDR      r2,|L1.900|
00018a  7a52              LDRB     r2,[r2,#9]
00018c  4302              ORRS     r2,r2,r0
00018e  4b7d              LDR      r3,|L1.900|
000190  725a              STRB     r2,[r3,#9]
000192  e004              B        |L1.414|
                  |L1.404|
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;502        *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
000194  4a7b              LDR      r2,|L1.900|
000196  7a52              LDRB     r2,[r2,#9]
000198  4382              BICS     r2,r2,r0
00019a  4b7a              LDR      r3,|L1.900|
00019c  725a              STRB     r2,[r3,#9]
                  |L1.414|
;;;503      }
;;;504    }
00019e  4770              BX       lr
;;;505    
                          ENDP

                  RCC_USBCLKConfig PROC
;;;518    *******************************************************************************/
;;;519    void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
0001a0  497d              LDR      r1,|L1.920|
;;;520    {
;;;521      /* Check the parameters */
;;;522      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;523    
;;;524      *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
0001a2  31d8              ADDS     r1,r1,#0xd8
0001a4  6008              STR      r0,[r1,#0]
;;;525    }
0001a6  4770              BX       lr
;;;526    
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;539    *******************************************************************************/
;;;540    void RCC_ADCCLKConfig(u32 RCC_PCLK2)
0001a8  4601              MOV      r1,r0
;;;541    {
;;;542      u32 tmpreg = 0;
0001aa  2000              MOVS     r0,#0
;;;543    
;;;544      /* Check the parameters */
;;;545      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;546    
;;;547      tmpreg = RCC->CFGR;
0001ac  4a75              LDR      r2,|L1.900|
0001ae  6850              LDR      r0,[r2,#4]
;;;548    
;;;549      /* Clear ADCPRE[1:0] bits */
;;;550      tmpreg &= CFGR_ADCPRE_Reset_Mask;
0001b0  f4204040          BIC      r0,r0,#0xc000
;;;551    
;;;552      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;553      tmpreg |= RCC_PCLK2;
0001b4  4308              ORRS     r0,r0,r1
;;;554    
;;;555      /* Store the new value */
;;;556      RCC->CFGR = tmpreg;
0001b6  6050              STR      r0,[r2,#4]
;;;557    }
0001b8  4770              BX       lr
;;;558    
                          ENDP

                  RCC_LSEConfig PROC
;;;570    *******************************************************************************/
;;;571    void RCC_LSEConfig(u8 RCC_LSE)
0001ba  2100              MOVS     r1,#0
;;;572    {
;;;573      /* Check the parameters */
;;;574      assert_param(IS_RCC_LSE(RCC_LSE));
;;;575    
;;;576      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;577      /* Reset LSEON bit */
;;;578      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
0001bc  4a71              LDR      r2,|L1.900|
0001be  3220              ADDS     r2,r2,#0x20
0001c0  7011              STRB     r1,[r2,#0]
;;;579    
;;;580      /* Reset LSEBYP bit */
;;;581      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
0001c2  4a70              LDR      r2,|L1.900|
0001c4  f8821020          STRB     r1,[r2,#0x20]
;;;582    
;;;583      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;584      switch(RCC_LSE)
0001c8  2801              CMP      r0,#1
0001ca  d002              BEQ      |L1.466|
0001cc  2804              CMP      r0,#4
0001ce  d10a              BNE      |L1.486|
0001d0  e004              B        |L1.476|
                  |L1.466|
;;;585      {
;;;586        case RCC_LSE_ON:
;;;587          /* Set LSEON bit */
;;;588          *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
0001d2  2101              MOVS     r1,#1
0001d4  4a6b              LDR      r2,|L1.900|
0001d6  3220              ADDS     r2,r2,#0x20
0001d8  7011              STRB     r1,[r2,#0]
;;;589          break;
0001da  e005              B        |L1.488|
                  |L1.476|
;;;590          
;;;591        case RCC_LSE_Bypass:
;;;592          /* Set LSEBYP and LSEON bits */
;;;593          *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
0001dc  2105              MOVS     r1,#5
0001de  4a69              LDR      r2,|L1.900|
0001e0  3220              ADDS     r2,r2,#0x20
0001e2  7011              STRB     r1,[r2,#0]
;;;594          break;            
0001e4  e000              B        |L1.488|
                  |L1.486|
;;;595          
;;;596        default:
;;;597          break;      
0001e6  bf00              NOP      
                  |L1.488|
0001e8  bf00              NOP                            ;589
;;;598      }
;;;599    }
0001ea  4770              BX       lr
;;;600    
                          ENDP

                  RCC_LSICmd PROC
;;;609    *******************************************************************************/
;;;610    void RCC_LSICmd(FunctionalState NewState)
0001ec  496b              LDR      r1,|L1.924|
;;;611    {
;;;612      /* Check the parameters */
;;;613      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;614    
;;;615      *(vu32 *) CSR_LSION_BB = (u32)NewState;
0001ee  6008              STR      r0,[r1,#0]
;;;616    }
0001f0  4770              BX       lr
;;;617    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;631    *******************************************************************************/
;;;632    void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
0001f2  4964              LDR      r1,|L1.900|
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;636    
;;;637      /* Select the RTC clock source */
;;;638      RCC->BDCR |= RCC_RTCCLKSource;
0001f4  6a09              LDR      r1,[r1,#0x20]
0001f6  4301              ORRS     r1,r1,r0
0001f8  4a62              LDR      r2,|L1.900|
0001fa  6211              STR      r1,[r2,#0x20]
;;;639    }
0001fc  4770              BX       lr
;;;640    
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;650    *******************************************************************************/
;;;651    void RCC_RTCCLKCmd(FunctionalState NewState)
0001fe  4967              LDR      r1,|L1.924|
;;;652    {
;;;653      /* Check the parameters */
;;;654      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;655    
;;;656      *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
000200  3944              SUBS     r1,r1,#0x44
000202  6008              STR      r0,[r1,#0]
;;;657    }
000204  4770              BX       lr
;;;658    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;666    *******************************************************************************/
;;;667    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000206  b530              PUSH     {r4,r5,lr}
;;;668    {
;;;669      u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
000208  2100              MOVS     r1,#0
00020a  2200              MOVS     r2,#0
00020c  2400              MOVS     r4,#0
00020e  2300              MOVS     r3,#0
;;;670    
;;;671      /* Get SYSCLK source -------------------------------------------------------*/
;;;672      tmp = RCC->CFGR & CFGR_SWS_Mask;
000210  4d5c              LDR      r5,|L1.900|
000212  686d              LDR      r5,[r5,#4]
000214  f005010c          AND      r1,r5,#0xc
;;;673    
;;;674      switch (tmp)
000218  b121              CBZ      r1,|L1.548|
00021a  2904              CMP      r1,#4
00021c  d005              BEQ      |L1.554|
00021e  2908              CMP      r1,#8
000220  d123              BNE      |L1.618|
000222  e005              B        |L1.560|
                  |L1.548|
;;;675      {
;;;676        case 0x00:  /* HSI used as system clock */
;;;677          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
000224  4d5e              LDR      r5,|L1.928|
000226  6005              STR      r5,[r0,#0]
;;;678          break;
000228  e022              B        |L1.624|
                  |L1.554|
;;;679    
;;;680        case 0x04:  /* HSE used as system clock */
;;;681          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
00022a  4d5d              LDR      r5,|L1.928|
00022c  6005              STR      r5,[r0,#0]
;;;682          break;
00022e  e01f              B        |L1.624|
                  |L1.560|
;;;683    
;;;684        case 0x08:  /* PLL used as system clock */
;;;685          /* Get PLL clock source and multiplication factor ----------------------*/
;;;686          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
000230  4d54              LDR      r5,|L1.900|
000232  686d              LDR      r5,[r5,#4]
000234  f4051270          AND      r2,r5,#0x3c0000
;;;687          pllmull = ( pllmull >> 18) + 2;
000238  2502              MOVS     r5,#2
00023a  eb054292          ADD      r2,r5,r2,LSR #18
;;;688    
;;;689          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
00023e  4d51              LDR      r5,|L1.900|
000240  686d              LDR      r5,[r5,#4]
000242  f4053480          AND      r4,r5,#0x10000
;;;690    
;;;691          if (pllsource == 0x00)
000246  b91c              CBNZ     r4,|L1.592|
;;;692          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;693            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
000248  4d56              LDR      r5,|L1.932|
00024a  4355              MULS     r5,r2,r5
00024c  6005              STR      r5,[r0,#0]
00024e  e00b              B        |L1.616|
                  |L1.592|
;;;694          }
;;;695          else
;;;696          {/* HSE selected as PLL clock entry */
;;;697    
;;;698            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
000250  4d4c              LDR      r5,|L1.900|
000252  686d              LDR      r5,[r5,#4]
000254  f4053500          AND      r5,r5,#0x20000
000258  b11d              CBZ      r5,|L1.610|
;;;699            {/* HSE oscillator clock divided by 2 */
;;;700    
;;;701              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
00025a  4d52              LDR      r5,|L1.932|
00025c  4355              MULS     r5,r2,r5
00025e  6005              STR      r5,[r0,#0]
000260  e002              B        |L1.616|
                  |L1.610|
;;;702            }
;;;703            else
;;;704            {
;;;705              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
000262  4d4f              LDR      r5,|L1.928|
000264  4355              MULS     r5,r2,r5
000266  6005              STR      r5,[r0,#0]
                  |L1.616|
;;;706            }
;;;707          }
;;;708          break;
000268  e002              B        |L1.624|
                  |L1.618|
;;;709    
;;;710        default:
;;;711          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
00026a  4d4d              LDR      r5,|L1.928|
00026c  6005              STR      r5,[r0,#0]
;;;712          break;
00026e  bf00              NOP      
                  |L1.624|
000270  bf00              NOP                            ;678
;;;713      }
;;;714    
;;;715      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;716      /* Get HCLK prescaler */
;;;717      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
000272  4d44              LDR      r5,|L1.900|
000274  686d              LDR      r5,[r5,#4]
000276  f00501f0          AND      r1,r5,#0xf0
;;;718      tmp = tmp >> 4;
00027a  0909              LSRS     r1,r1,#4
;;;719      presc = APBAHBPrescTable[tmp];
00027c  4d4a              LDR      r5,|L1.936|
00027e  5c6b              LDRB     r3,[r5,r1]
;;;720    
;;;721      /* HCLK clock frequency */
;;;722      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
000280  6805              LDR      r5,[r0,#0]
000282  40dd              LSRS     r5,r5,r3
000284  6045              STR      r5,[r0,#4]
;;;723    
;;;724      /* Get PCLK1 prescaler */
;;;725      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000286  4d3f              LDR      r5,|L1.900|
000288  686d              LDR      r5,[r5,#4]
00028a  f40561e0          AND      r1,r5,#0x700
;;;726      tmp = tmp >> 8;
00028e  0a09              LSRS     r1,r1,#8
;;;727      presc = APBAHBPrescTable[tmp];
000290  4d45              LDR      r5,|L1.936|
000292  5c6b              LDRB     r3,[r5,r1]
;;;728    
;;;729      /* PCLK1 clock frequency */
;;;730      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000294  6845              LDR      r5,[r0,#4]
000296  40dd              LSRS     r5,r5,r3
000298  6085              STR      r5,[r0,#8]
;;;731    
;;;732      /* Get PCLK2 prescaler */
;;;733      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
00029a  4d3a              LDR      r5,|L1.900|
00029c  686d              LDR      r5,[r5,#4]
00029e  f4055160          AND      r1,r5,#0x3800
;;;734      tmp = tmp >> 11;
0002a2  0ac9              LSRS     r1,r1,#11
;;;735      presc = APBAHBPrescTable[tmp];
0002a4  4d40              LDR      r5,|L1.936|
0002a6  5c6b              LDRB     r3,[r5,r1]
;;;736    
;;;737      /* PCLK2 clock frequency */
;;;738      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0002a8  6845              LDR      r5,[r0,#4]
0002aa  40dd              LSRS     r5,r5,r3
0002ac  60c5              STR      r5,[r0,#0xc]
;;;739    
;;;740      /* Get ADCCLK prescaler */
;;;741      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
0002ae  4d35              LDR      r5,|L1.900|
0002b0  686d              LDR      r5,[r5,#4]
0002b2  f4054140          AND      r1,r5,#0xc000
;;;742      tmp = tmp >> 14;
0002b6  0b89              LSRS     r1,r1,#14
;;;743      presc = ADCPrescTable[tmp];
0002b8  4d3c              LDR      r5,|L1.940|
0002ba  5c6b              LDRB     r3,[r5,r1]
;;;744    
;;;745      /* ADCCLK clock frequency */
;;;746      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
0002bc  68c5              LDR      r5,[r0,#0xc]
0002be  fbb5f5f3          UDIV     r5,r5,r3
0002c2  6105              STR      r5,[r0,#0x10]
;;;747    }
0002c4  bd30              POP      {r4,r5,pc}
;;;748    
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;766    *******************************************************************************/
;;;767    void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
0002c6  b129              CBZ      r1,|L1.724|
;;;768    {
;;;769      /* Check the parameters */
;;;770      assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;771      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;772    
;;;773      if (NewState != DISABLE)
;;;774      {
;;;775        RCC->AHBENR |= RCC_AHBPeriph;
0002c8  4a2e              LDR      r2,|L1.900|
0002ca  6952              LDR      r2,[r2,#0x14]
0002cc  4302              ORRS     r2,r2,r0
0002ce  4b2d              LDR      r3,|L1.900|
0002d0  615a              STR      r2,[r3,#0x14]
0002d2  e004              B        |L1.734|
                  |L1.724|
;;;776      }
;;;777      else
;;;778      {
;;;779        RCC->AHBENR &= ~RCC_AHBPeriph;
0002d4  4a2b              LDR      r2,|L1.900|
0002d6  6952              LDR      r2,[r2,#0x14]
0002d8  4382              BICS     r2,r2,r0
0002da  4b2a              LDR      r3,|L1.900|
0002dc  615a              STR      r2,[r3,#0x14]
                  |L1.734|
;;;780      }
;;;781    }
0002de  4770              BX       lr
;;;782    
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;799    *******************************************************************************/
;;;800    void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
0002e0  b129              CBZ      r1,|L1.750|
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;804      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;805    
;;;806      if (NewState != DISABLE)
;;;807      {
;;;808        RCC->APB2ENR |= RCC_APB2Periph;
0002e2  4a28              LDR      r2,|L1.900|
0002e4  6992              LDR      r2,[r2,#0x18]
0002e6  4302              ORRS     r2,r2,r0
0002e8  4b26              LDR      r3,|L1.900|
0002ea  619a              STR      r2,[r3,#0x18]
0002ec  e004              B        |L1.760|
                  |L1.750|
;;;809      }
;;;810      else
;;;811      {
;;;812        RCC->APB2ENR &= ~RCC_APB2Periph;
0002ee  4a25              LDR      r2,|L1.900|
0002f0  6992              LDR      r2,[r2,#0x18]
0002f2  4382              BICS     r2,r2,r0
0002f4  4b23              LDR      r3,|L1.900|
0002f6  619a              STR      r2,[r3,#0x18]
                  |L1.760|
;;;813      }
;;;814    }
0002f8  4770              BX       lr
;;;815    
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;833    *******************************************************************************/
;;;834    void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
0002fa  b129              CBZ      r1,|L1.776|
;;;835    {
;;;836      /* Check the parameters */
;;;837      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;838      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;839    
;;;840      if (NewState != DISABLE)
;;;841      {
;;;842        RCC->APB1ENR |= RCC_APB1Periph;
0002fc  4a21              LDR      r2,|L1.900|
0002fe  69d2              LDR      r2,[r2,#0x1c]
000300  4302              ORRS     r2,r2,r0
000302  4b20              LDR      r3,|L1.900|
000304  61da              STR      r2,[r3,#0x1c]
000306  e004              B        |L1.786|
                  |L1.776|
;;;843      }
;;;844      else
;;;845      {
;;;846        RCC->APB1ENR &= ~RCC_APB1Periph;
000308  4a1e              LDR      r2,|L1.900|
00030a  69d2              LDR      r2,[r2,#0x1c]
00030c  4382              BICS     r2,r2,r0
00030e  4b1d              LDR      r3,|L1.900|
000310  61da              STR      r2,[r3,#0x1c]
                  |L1.786|
;;;847      }
;;;848    }
000312  4770              BX       lr
;;;849    
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;865    *******************************************************************************/
;;;866    void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
000314  b129              CBZ      r1,|L1.802|
;;;867    {
;;;868      /* Check the parameters */
;;;869      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;870      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;871    
;;;872      if (NewState != DISABLE)
;;;873      {
;;;874        RCC->APB2RSTR |= RCC_APB2Periph;
000316  4a1b              LDR      r2,|L1.900|
000318  68d2              LDR      r2,[r2,#0xc]
00031a  4302              ORRS     r2,r2,r0
00031c  4b19              LDR      r3,|L1.900|
00031e  60da              STR      r2,[r3,#0xc]
000320  e004              B        |L1.812|
                  |L1.802|
;;;875      }
;;;876      else
;;;877      {
;;;878        RCC->APB2RSTR &= ~RCC_APB2Periph;
000322  4a18              LDR      r2,|L1.900|
000324  68d2              LDR      r2,[r2,#0xc]
000326  4382              BICS     r2,r2,r0
000328  4b16              LDR      r3,|L1.900|
00032a  60da              STR      r2,[r3,#0xc]
                  |L1.812|
;;;879      }
;;;880    }
00032c  4770              BX       lr
;;;881    
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;898    *******************************************************************************/
;;;899    void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
00032e  b129              CBZ      r1,|L1.828|
;;;900    {
;;;901      /* Check the parameters */
;;;902      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;903      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;904    
;;;905      if (NewState != DISABLE)
;;;906      {
;;;907        RCC->APB1RSTR |= RCC_APB1Periph;
000330  4a14              LDR      r2,|L1.900|
000332  6912              LDR      r2,[r2,#0x10]
000334  4302              ORRS     r2,r2,r0
000336  4b13              LDR      r3,|L1.900|
000338  611a              STR      r2,[r3,#0x10]
00033a  e004              B        |L1.838|
                  |L1.828|
;;;908      }
;;;909      else
;;;910      {
;;;911        RCC->APB1RSTR &= ~RCC_APB1Periph;
00033c  4a11              LDR      r2,|L1.900|
00033e  6912              LDR      r2,[r2,#0x10]
000340  4382              BICS     r2,r2,r0
000342  4b10              LDR      r3,|L1.900|
000344  611a              STR      r2,[r3,#0x10]
                  |L1.838|
;;;912      }
;;;913    }
000346  4770              BX       lr
;;;914    
                          ENDP

                  RCC_BackupResetCmd PROC
;;;922    *******************************************************************************/
;;;923    void RCC_BackupResetCmd(FunctionalState NewState)
000348  4914              LDR      r1,|L1.924|
;;;924    {
;;;925      /* Check the parameters */
;;;926      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;927    
;;;928      *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
00034a  3940              SUBS     r1,r1,#0x40
00034c  6008              STR      r0,[r1,#0]
;;;929    }
00034e  4770              BX       lr
;;;930    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;938    *******************************************************************************/
;;;939    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000350  4911              LDR      r1,|L1.920|
;;;940    {
;;;941      /* Check the parameters */
;;;942      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;943    
;;;944      *(vu32 *) CR_CSSON_BB = (u32)NewState;
000352  64c8              STR      r0,[r1,#0x4c]
;;;945    }
000354  4770              BX       lr
;;;946    
                          ENDP

                  RCC_MCOConfig PROC
;;;959    *******************************************************************************/
;;;960    void RCC_MCOConfig(u8 RCC_MCO)
000356  490b              LDR      r1,|L1.900|
;;;961    {
;;;962      /* Check the parameters */
;;;963      assert_param(IS_RCC_MCO(RCC_MCO));
;;;964    
;;;965      /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;966      *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000358  71c8              STRB     r0,[r1,#7]
;;;967    }
00035a  4770              BX       lr
;;;968    
                          ENDP

                  RCC_ClearFlag PROC
;;;1038   *******************************************************************************/
;;;1039   void RCC_ClearFlag(void)
00035c  4809              LDR      r0,|L1.900|
;;;1040   {
;;;1041     /* Set RMVF bit to clear the reset flags */
;;;1042     RCC->CSR |= CSR_RMVF_Set;
00035e  6a40              LDR      r0,[r0,#0x24]
000360  f0407080          ORR      r0,r0,#0x1000000
000364  4907              LDR      r1,|L1.900|
000366  6248              STR      r0,[r1,#0x24]
;;;1043   }
000368  4770              BX       lr
;;;1044   
                          ENDP

                  RCC_GetITStatus PROC
;;;1058   *******************************************************************************/
;;;1059   ITStatus RCC_GetITStatus(u8 RCC_IT)
00036a  4601              MOV      r1,r0
;;;1060   {
;;;1061     ITStatus bitstatus = RESET;
00036c  2000              MOVS     r0,#0
;;;1062   
;;;1063     /* Check the parameters */
;;;1064     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1065   
;;;1066     /* Check the status of the specified RCC interrupt */
;;;1067     if ((RCC->CIR & RCC_IT) != (u32)RESET)
00036e  4a05              LDR      r2,|L1.900|
000370  6892              LDR      r2,[r2,#8]
000372  400a              ANDS     r2,r2,r1
000374  b10a              CBZ      r2,|L1.890|
;;;1068     {
;;;1069       bitstatus = SET;
000376  2001              MOVS     r0,#1
000378  e000              B        |L1.892|
                  |L1.890|
;;;1070     }
;;;1071     else
;;;1072     {
;;;1073       bitstatus = RESET;
00037a  2000              MOVS     r0,#0
                  |L1.892|
;;;1074     }
;;;1075   
;;;1076     /* Return the RCC_IT status */
;;;1077     return  bitstatus;
;;;1078   }
00037c  4770              BX       lr
;;;1079   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1093   *******************************************************************************/
;;;1094   void RCC_ClearITPendingBit(u8 RCC_IT)
00037e  4901              LDR      r1,|L1.900|
;;;1095   {
;;;1096     /* Check the parameters */
;;;1097     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1098   
;;;1099     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1100        pending bits */
;;;1101     *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
000380  7288              STRB     r0,[r1,#0xa]
;;;1102   }
000382  4770              BX       lr
;;;1103   
                          ENDP

                  |L1.900|
                          DCD      0x40021000
                  |L1.904|
                          DCD      0xf8ff0000
                  |L1.908|
                          DCD      0xfef6ffff
                  |L1.912|
                          DCD      HSEStatus
                  |L1.916|
                          DCD      StartUpCounter
                  |L1.920|
                          DCD      0x42420000
                  |L1.924|
                          DCD      0x42420480
                  |L1.928|
                          DCD      0x007a1200
                  |L1.932|
                          DCD      0x003d0900
                  |L1.936|
                          DCD      APBAHBPrescTable
                  |L1.940|
                          DCD      ADCPrescTable

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08

                          AREA ||.data||, DATA, ALIGN=2

                  HSEStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  StartUpCounter
                          DCD      0x00000000
